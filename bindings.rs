/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_authentication {
    _unused: [u8; 0],
}
pub type pulsar_authentication_t = _pulsar_authentication;
pub type token_supplier = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn pulsar_authentication_create(
        dynamicLibPath: *const ::std::os::raw::c_char,
        authParamsString: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_tls_create(
        certificatePath: *const ::std::os::raw::c_char,
        privateKeyPath: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_token_create(
        token: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_token_create_with_supplier(
        tokenSupplier: token_supplier,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_athenz_create(
        authParamsString: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_free(authentication: *mut pulsar_authentication_t);
}
pub const pulsar_logger_level_t_pulsar_DEBUG: pulsar_logger_level_t = 0;
pub const pulsar_logger_level_t_pulsar_INFO: pulsar_logger_level_t = 1;
pub const pulsar_logger_level_t_pulsar_WARN: pulsar_logger_level_t = 2;
pub const pulsar_logger_level_t_pulsar_ERROR: pulsar_logger_level_t = 3;
pub type pulsar_logger_level_t = u32;
pub type pulsar_logger = ::std::option::Option<
    unsafe extern "C" fn(
        level: pulsar_logger_level_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_client_configuration {
    _unused: [u8; 0],
}
pub type pulsar_client_configuration_t = _pulsar_client_configuration;
extern "C" {
    pub fn pulsar_client_configuration_create() -> *mut pulsar_client_configuration_t;
}
extern "C" {
    pub fn pulsar_client_configuration_free(conf: *mut pulsar_client_configuration_t);
}
extern "C" {
    #[doc = " Set the authentication method to be used with the broker"]
    #[doc = ""]
    #[doc = " @param authentication the authentication data to use"]
    pub fn pulsar_client_configuration_set_auth(
        conf: *mut pulsar_client_configuration_t,
        authentication: *mut pulsar_authentication_t,
    );
}
extern "C" {
    #[doc = " Set timeout on client operations (subscribe, create producer, close, unsubscribe)"]
    #[doc = " Default is 30 seconds."]
    #[doc = ""]
    #[doc = " @param timeout the timeout after which the operation will be considered as failed"]
    pub fn pulsar_client_configuration_set_operation_timeout_seconds(
        conf: *mut pulsar_client_configuration_t,
        timeout: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the client operations timeout in seconds"]
    pub fn pulsar_client_configuration_get_operation_timeout_seconds(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of IO threads to be used by the Pulsar client. Default is 1"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " @param threads number of threads"]
    pub fn pulsar_client_configuration_set_io_threads(
        conf: *mut pulsar_client_configuration_t,
        threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the number of IO threads to use"]
    pub fn pulsar_client_configuration_get_io_threads(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of threads to be used by the Pulsar client when delivering messages"]
    #[doc = " through message listener. Default is 1 thread per Pulsar client."]
    #[doc = ""]
    #[doc = " If using more than 1 thread, messages for distinct MessageListener will be"]
    #[doc = " delivered in different threads, however a single MessageListener will always"]
    #[doc = " be assigned to the same thread."]
    #[doc = ""]
    #[doc = " @param threads number of threads"]
    pub fn pulsar_client_configuration_set_message_listener_threads(
        conf: *mut pulsar_client_configuration_t,
        threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the number of IO threads to use"]
    pub fn pulsar_client_configuration_get_message_listener_threads(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of concurrent lookup-requests allowed on each broker-connection to prevent overload on broker."]
    #[doc = " <i>(default: 50000)</i> It should be configured with higher value only in case of it requires to"]
    #[doc = " produce/subscribe on"]
    #[doc = " thousands of topic using created {@link PulsarClient}"]
    #[doc = ""]
    #[doc = " @param concurrentLookupRequest"]
    pub fn pulsar_client_configuration_set_concurrent_lookup_request(
        conf: *mut pulsar_client_configuration_t,
        concurrentLookupRequest: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return Get configured total allowed concurrent lookup-request."]
    pub fn pulsar_client_configuration_get_concurrent_lookup_request(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_logger(
        conf: *mut pulsar_client_configuration_t,
        logger: pulsar_logger,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_set_use_tls(
        conf: *mut pulsar_client_configuration_t,
        useTls: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_use_tls(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_tls_trust_certs_file_path(
        conf: *mut pulsar_client_configuration_t,
        tlsTrustCertsFilePath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_tls_trust_certs_file_path(
        conf: *mut pulsar_client_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_client_configuration_set_tls_allow_insecure_connection(
        conf: *mut pulsar_client_configuration_t,
        allowInsecure: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_tls_allow_insecure_connection(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_stats_interval_in_seconds(
        conf: *mut pulsar_client_configuration_t,
        interval: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_validate_hostname(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_validate_hostname(
        conf: *mut pulsar_client_configuration_t,
        validateHostName: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_stats_interval_in_seconds(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_uint;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_string_map {
    _unused: [u8; 0],
}
pub type pulsar_string_map_t = _pulsar_string_map;
extern "C" {
    pub fn pulsar_string_map_create() -> *mut pulsar_string_map_t;
}
extern "C" {
    pub fn pulsar_string_map_free(map: *mut pulsar_string_map_t);
}
extern "C" {
    pub fn pulsar_string_map_size(map: *mut pulsar_string_map_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_string_map_put(
        map: *mut pulsar_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_string_map_get(
        map: *mut pulsar_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_string_map_get_key(
        map: *mut pulsar_string_map_t,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_string_map_get_value(
        map: *mut pulsar_string_map_t,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_message {
    _unused: [u8; 0],
}
pub type pulsar_message_t = _pulsar_message;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_message_id {
    _unused: [u8; 0],
}
pub type pulsar_message_id_t = _pulsar_message_id;
extern "C" {
    pub fn pulsar_message_create() -> *mut pulsar_message_t;
}
extern "C" {
    pub fn pulsar_message_free(message: *mut pulsar_message_t);
}
extern "C" {
    #[doc = " Builder"]
    pub fn pulsar_message_set_content(
        message: *mut pulsar_message_t,
        data: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " Set content of the message to a buffer already allocated by the caller. No copies of"]
    #[doc = " this buffer will be made. The caller is responsible to ensure the memory buffer is"]
    #[doc = " valid until the message has been persisted (or an error is returned)."]
    pub fn pulsar_message_set_allocated_content(
        message: *mut pulsar_message_t,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn pulsar_message_set_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " set partition key for the message routing"]
    #[doc = " @param hash of this key is used to determine message's topic partition"]
    pub fn pulsar_message_set_partition_key(
        message: *mut pulsar_message_t,
        partitionKey: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sets the ordering key of the message for message dispatch in Key_Shared mode."]
    #[doc = " @param the ordering key for the message"]
    pub fn pulsar_message_set_ordering_key(
        message: *mut pulsar_message_t,
        orderingKey: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set the event timestamp for the message."]
    pub fn pulsar_message_set_event_timestamp(message: *mut pulsar_message_t, eventTimestamp: u64);
}
extern "C" {
    #[doc = " Specify a custom sequence id for the message being published."]
    #[doc = " <p>"]
    #[doc = " The sequence id can be used for deduplication purposes and it needs to follow these rules:"]
    #[doc = " <ol>"]
    #[doc = " <li><code>sequenceId >= 0</code>"]
    #[doc = " <li>Sequence id for a message needs to be greater than sequence id for earlier messages:"]
    #[doc = " <code>sequenceId(N+1) > sequenceId(N)</code>"]
    #[doc = " <li>It's not necessary for sequence ids to be consecutive. There can be holes between messages. Eg. the"]
    #[doc = " <code>sequenceId</code> could represent an offset or a cumulative size."]
    #[doc = " </ol>"]
    #[doc = ""]
    #[doc = " @param sequenceId"]
    #[doc = "            the sequence id to assign to the current message"]
    pub fn pulsar_message_set_sequence_id(message: *mut pulsar_message_t, sequenceId: i64);
}
extern "C" {
    #[doc = " Specify a delay for the delivery of the messages."]
    #[doc = ""]
    #[doc = " @param delay the delay in milliseconds"]
    pub fn pulsar_message_set_deliver_after(message: *mut pulsar_message_t, delayMillis: u64);
}
extern "C" {
    #[doc = " Specify the this message should not be delivered earlier than the"]
    #[doc = " specified timestamp."]
    #[doc = ""]
    #[doc = " @param deliveryTimestamp UTC based timestamp in milliseconds"]
    pub fn pulsar_message_set_deliver_at(
        message: *mut pulsar_message_t,
        deliveryTimestampMillis: u64,
    );
}
extern "C" {
    #[doc = " override namespace replication clusters.  note that it is the"]
    #[doc = " caller's responsibility to provide valid cluster names, and that"]
    #[doc = " all clusters have been previously configured as topics."]
    #[doc = ""]
    #[doc = " given an empty list, the message will replicate per the namespace"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " @param clusters where to send this message."]
    pub fn pulsar_message_set_replication_clusters(
        message: *mut pulsar_message_t,
        clusters: *mut *const ::std::os::raw::c_char,
        size: usize,
    );
}
extern "C" {
    #[doc = " Do not replicate this message"]
    #[doc = " @param flag if true, disable replication, otherwise use default"]
    #[doc = " replication"]
    pub fn pulsar_message_disable_replication(
        message: *mut pulsar_message_t,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return the properties attached to the message."]
    #[doc = " Properties are application defined key/value pairs that will be attached to the message"]
    #[doc = ""]
    #[doc = " @return an unmodifiable view of the properties map"]
    pub fn pulsar_message_get_properties(
        message: *mut pulsar_message_t,
    ) -> *mut pulsar_string_map_t;
}
extern "C" {
    #[doc = " Check whether the message has a specific property attached."]
    #[doc = ""]
    #[doc = " @param name the name of the property to check"]
    #[doc = " @return true if the message has the specified property"]
    #[doc = " @return false if the property is not defined"]
    pub fn pulsar_message_has_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the value of a specific property"]
    #[doc = ""]
    #[doc = " @param name the name of the property"]
    #[doc = " @return the value of the property or null if the property was not defined"]
    pub fn pulsar_message_get_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the content of the message"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return the pointer to the message payload"]
    pub fn pulsar_message_get_data(message: *mut pulsar_message_t)
        -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the length of the message"]
    #[doc = ""]
    #[doc = " @return the length of the message payload"]
    pub fn pulsar_message_get_length(message: *mut pulsar_message_t) -> u32;
}
extern "C" {
    #[doc = " Get the unique message ID associated with this message."]
    #[doc = ""]
    #[doc = " The message id can be used to univocally refer to a message without having to keep the entire payload"]
    #[doc = " in memory."]
    #[doc = ""]
    #[doc = " Only messages received from the consumer will have a message id assigned."]
    #[doc = ""]
    pub fn pulsar_message_get_message_id(
        message: *mut pulsar_message_t,
    ) -> *mut pulsar_message_id_t;
}
extern "C" {
    #[doc = " Get the partition key for this message"]
    #[doc = " @return key string that is hashed to determine message's topic partition"]
    pub fn pulsar_message_get_partitionKey(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_has_partition_key(
        message: *mut pulsar_message_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the ordering key of the message for message dispatch in Key_Shared mode."]
    #[doc = " Partition key Will be used if ordering key not specified"]
    pub fn pulsar_message_get_orderingKey(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_has_ordering_key(message: *mut pulsar_message_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the UTC based timestamp in milliseconds referring to when the message was published by the client"]
    #[doc = " producer"]
    pub fn pulsar_message_get_publish_timestamp(message: *mut pulsar_message_t) -> u64;
}
extern "C" {
    #[doc = " Get the event timestamp associated with this message. It is set by the client producer."]
    pub fn pulsar_message_get_event_timestamp(message: *mut pulsar_message_t) -> u64;
}
extern "C" {
    pub fn pulsar_message_get_topic_name(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " MessageId representing the \"earliest\" or \"oldest available\" message stored in the topic"]
    pub fn pulsar_message_id_earliest() -> *const pulsar_message_id_t;
}
extern "C" {
    #[doc = " MessageId representing the \"latest\" or \"last published\" message in the topic"]
    pub fn pulsar_message_id_latest() -> *const pulsar_message_id_t;
}
extern "C" {
    #[doc = " Serialize the message id into a binary string for storing"]
    pub fn pulsar_message_id_serialize(
        messageId: *mut pulsar_message_id_t,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Deserialize a message id from a binary string"]
    pub fn pulsar_message_id_deserialize(
        buffer: *const ::std::os::raw::c_void,
        len: u32,
    ) -> *mut pulsar_message_id_t;
}
extern "C" {
    pub fn pulsar_message_id_str(
        messageId: *mut pulsar_message_id_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_id_free(messageId: *mut pulsar_message_id_t);
}
pub const pulsar_result_pulsar_result_Ok: pulsar_result = 0;
#[doc = " Operation successful"]
pub const pulsar_result_pulsar_result_UnknownError: pulsar_result = 1;
#[doc = " Unknown error happened on broker"]
pub const pulsar_result_pulsar_result_InvalidConfiguration: pulsar_result = 2;
#[doc = " Invalid configuration"]
pub const pulsar_result_pulsar_result_Timeout: pulsar_result = 3;
#[doc = " Operation timed out"]
pub const pulsar_result_pulsar_result_LookupError: pulsar_result = 4;
#[doc = " Broker lookup failed"]
pub const pulsar_result_pulsar_result_ConnectError: pulsar_result = 5;
#[doc = " Failed to connect to broker"]
pub const pulsar_result_pulsar_result_ReadError: pulsar_result = 6;
#[doc = " Failed to read from socket"]
pub const pulsar_result_pulsar_result_AuthenticationError: pulsar_result = 7;
#[doc = " Authentication failed on broker"]
pub const pulsar_result_pulsar_result_AuthorizationError: pulsar_result = 8;
#[doc = " Client is not authorized to create producer/consumer"]
pub const pulsar_result_pulsar_result_ErrorGettingAuthenticationData: pulsar_result = 9;
#[doc = " Client cannot find authorization data"]
pub const pulsar_result_pulsar_result_BrokerMetadataError: pulsar_result = 10;
#[doc = " Broker failed in updating metadata"]
pub const pulsar_result_pulsar_result_BrokerPersistenceError: pulsar_result = 11;
#[doc = " Broker failed to persist entry"]
pub const pulsar_result_pulsar_result_ChecksumError: pulsar_result = 12;
#[doc = " Corrupt message checksum failure"]
pub const pulsar_result_pulsar_result_ConsumerBusy: pulsar_result = 13;
#[doc = " Exclusive consumer is already connected"]
pub const pulsar_result_pulsar_result_NotConnected: pulsar_result = 14;
#[doc = " Producer/Consumer is not currently connected to broker"]
pub const pulsar_result_pulsar_result_AlreadyClosed: pulsar_result = 15;
#[doc = " Producer/Consumer is already closed and not accepting any operation"]
pub const pulsar_result_pulsar_result_InvalidMessage: pulsar_result = 16;
#[doc = " Error in publishing an already used message"]
pub const pulsar_result_pulsar_result_ConsumerNotInitialized: pulsar_result = 17;
#[doc = " Consumer is not initialized"]
pub const pulsar_result_pulsar_result_ProducerNotInitialized: pulsar_result = 18;
#[doc = " Producer is not initialized"]
pub const pulsar_result_pulsar_result_TooManyLookupRequestException: pulsar_result = 19;
#[doc = " Too Many concurrent LookupRequest"]
pub const pulsar_result_pulsar_result_InvalidTopicName: pulsar_result = 20;
#[doc = " Invalid topic name"]
pub const pulsar_result_pulsar_result_InvalidUrl: pulsar_result = 21;
#[doc = " Client Initialized with Invalid Broker Url (VIP Url passed to Client"]
#[doc = " Constructor)"]
pub const pulsar_result_pulsar_result_ServiceUnitNotReady: pulsar_result = 22;
#[doc = " Service Unit unloaded between client did lookup and"]
#[doc = " producer/consumer got created"]
pub const pulsar_result_pulsar_result_OperationNotSupported: pulsar_result = 23;
#[doc = " Service Unit unloaded between client did lookup and"]
#[doc = " producer/consumer got created"]
pub const pulsar_result_pulsar_result_ProducerBlockedQuotaExceededError: pulsar_result = 24;
#[doc = " Producer is blocked"]
pub const pulsar_result_pulsar_result_ProducerBlockedQuotaExceededException: pulsar_result = 25;
#[doc = " Producer is getting exception"]
pub const pulsar_result_pulsar_result_ProducerQueueIsFull: pulsar_result = 26;
#[doc = " Producer queue is full"]
pub const pulsar_result_pulsar_result_MessageTooBig: pulsar_result = 27;
#[doc = " Trying to send a messages exceeding the max size"]
pub const pulsar_result_pulsar_result_TopicNotFound: pulsar_result = 28;
#[doc = " Topic not found"]
pub const pulsar_result_pulsar_result_SubscriptionNotFound: pulsar_result = 29;
#[doc = " Subscription not found"]
pub const pulsar_result_pulsar_result_ConsumerNotFound: pulsar_result = 30;
#[doc = " Consumer not found"]
pub const pulsar_result_pulsar_result_UnsupportedVersionError: pulsar_result = 31;
#[doc = " Error when an older client/version doesn't support a required"]
#[doc = " feature"]
pub const pulsar_result_pulsar_result_TopicTerminated: pulsar_result = 32;
#[doc = " Topic was already terminated"]
pub const pulsar_result_pulsar_result_CryptoError: pulsar_result = 33;
pub type pulsar_result = u32;
extern "C" {
    pub fn pulsar_result_str(result: pulsar_result) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_producer {
    _unused: [u8; 0],
}
pub type pulsar_producer_t = _pulsar_producer;
pub type pulsar_send_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: pulsar_result,
        msgId: *mut pulsar_message_id_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_close_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, ctx: *mut ::std::os::raw::c_void),
>;
pub type pulsar_flush_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, ctx: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @return the topic to which producer is publishing to"]
    pub fn pulsar_producer_get_topic(
        producer: *mut pulsar_producer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the producer name which could have been assigned by the system or specified by the client"]
    pub fn pulsar_producer_get_producer_name(
        producer: *mut pulsar_producer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Publish a message on the topic associated with this Producer."]
    #[doc = ""]
    #[doc = " This method will block until the message will be accepted and persisted"]
    #[doc = " by the broker. In case of errors, the client library will try to"]
    #[doc = " automatically recover and use a different broker."]
    #[doc = ""]
    #[doc = " If it wasn't possible to successfully publish the message within the sendTimeout,"]
    #[doc = " an error will be returned."]
    #[doc = ""]
    #[doc = " This method is equivalent to asyncSend() and wait until the callback is triggered."]
    #[doc = ""]
    #[doc = " @param msg message to publish"]
    #[doc = " @return ResultOk if the message was published successfully"]
    #[doc = " @return ResultWriteError if it wasn't possible to publish the message"]
    pub fn pulsar_producer_send(
        producer: *mut pulsar_producer_t,
        msg: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " Asynchronously publish a message on the topic associated with this Producer."]
    #[doc = ""]
    #[doc = " This method will initiate the publish operation and return immediately. The"]
    #[doc = " provided callback will be triggered when the message has been be accepted and persisted"]
    #[doc = " by the broker. In case of errors, the client library will try to"]
    #[doc = " automatically recover and use a different broker."]
    #[doc = ""]
    #[doc = " If it wasn't possible to successfully publish the message within the sendTimeout, the"]
    #[doc = " callback will be triggered with a Result::WriteError code."]
    #[doc = ""]
    #[doc = " @param msg message to publish"]
    #[doc = " @param callback the callback to get notification of the completion"]
    pub fn pulsar_producer_send_async(
        producer: *mut pulsar_producer_t,
        msg: *mut pulsar_message_t,
        callback: pulsar_send_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the last sequence id that was published by this producer."]
    #[doc = ""]
    #[doc = " This represent either the automatically assigned or custom sequence id (set on the MessageBuilder) that"]
    #[doc = " was published and acknowledged by the broker."]
    #[doc = ""]
    #[doc = " After recreating a producer with the same producer name, this will return the last message that was"]
    #[doc = " published in"]
    #[doc = " the previous producer session, or -1 if there no message was ever published."]
    #[doc = ""]
    #[doc = " @return the last sequence id published by this producer"]
    pub fn pulsar_producer_get_last_sequence_id(producer: *mut pulsar_producer_t) -> i64;
}
extern "C" {
    #[doc = " Close the producer and release resources allocated."]
    #[doc = ""]
    #[doc = " No more writes will be accepted from this producer. Waits until"]
    #[doc = " all pending write requests are persisted. In case of errors,"]
    #[doc = " pending writes will not be retried."]
    #[doc = ""]
    #[doc = " @return an error code to indicate the success or failure"]
    pub fn pulsar_producer_close(producer: *mut pulsar_producer_t) -> pulsar_result;
}
extern "C" {
    #[doc = " Close the producer and release resources allocated."]
    #[doc = ""]
    #[doc = " No more writes will be accepted from this producer. The provided callback will be"]
    #[doc = " triggered when all pending write requests are persisted. In case of errors,"]
    #[doc = " pending writes will not be retried."]
    pub fn pulsar_producer_close_async(
        producer: *mut pulsar_producer_t,
        callback: pulsar_close_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_flush(producer: *mut pulsar_producer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_producer_flush_async(
        producer: *mut pulsar_producer_t,
        callback: pulsar_flush_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_free(producer: *mut pulsar_producer_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_consumer {
    _unused: [u8; 0],
}
pub type pulsar_consumer_t = _pulsar_consumer;
pub type pulsar_result_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @return the topic this consumer is subscribed to"]
    pub fn pulsar_consumer_get_topic(
        consumer: *mut pulsar_consumer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the consumer name"]
    pub fn pulsar_consumer_get_subscription_name(
        consumer: *mut pulsar_consumer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Unsubscribe the current consumer from the topic."]
    #[doc = ""]
    #[doc = " This method will block until the operation is completed. Once the consumer is"]
    #[doc = " unsubscribed, no more messages will be received and subsequent new messages"]
    #[doc = " will not be retained for this consumer."]
    #[doc = ""]
    #[doc = " This consumer object cannot be reused."]
    #[doc = ""]
    #[doc = " @see asyncUnsubscribe"]
    #[doc = " @return Result::ResultOk if the unsubscribe operation completed successfully"]
    #[doc = " @return Result::ResultError if the unsubscribe operation failed"]
    pub fn pulsar_consumer_unsubscribe(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    #[doc = " Asynchronously unsubscribe the current consumer from the topic."]
    #[doc = ""]
    #[doc = " This method will block until the operation is completed. Once the consumer is"]
    #[doc = " unsubscribed, no more messages will be received and subsequent new messages"]
    #[doc = " will not be retained for this consumer."]
    #[doc = ""]
    #[doc = " This consumer object cannot be reused."]
    #[doc = ""]
    #[doc = " @param callback the callback to get notified when the operation is complete"]
    pub fn pulsar_consumer_unsubscribe_async(
        consumer: *mut pulsar_consumer_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Receive a single message."]
    #[doc = ""]
    #[doc = " If a message is not immediately available, this method will block until a new"]
    #[doc = " message is available."]
    #[doc = ""]
    #[doc = " @param msg a non-const reference where the received message will be copied"]
    #[doc = " @return ResultOk when a message is received"]
    #[doc = " @return ResultInvalidConfiguration if a message listener had been set in the configuration"]
    pub fn pulsar_consumer_receive(
        consumer: *mut pulsar_consumer_t,
        msg: *mut *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " @param msg a non-const reference where the received message will be copied"]
    #[doc = " @param timeoutMs the receive timeout in milliseconds"]
    #[doc = " @return ResultOk if a message was received"]
    #[doc = " @return ResultTimeout if the receive timeout was triggered"]
    #[doc = " @return ResultInvalidConfiguration if a message listener had been set in the configuration"]
    pub fn pulsar_consumer_receive_with_timeout(
        consumer: *mut pulsar_consumer_t,
        msg: *mut *mut pulsar_message_t,
        timeoutMs: ::std::os::raw::c_int,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " Acknowledge the reception of a single message."]
    #[doc = ""]
    #[doc = " This method will block until an acknowledgement is sent to the broker. After"]
    #[doc = " that, the message will not be re-delivered to this consumer."]
    #[doc = ""]
    #[doc = " @see asyncAcknowledge"]
    #[doc = " @param message the message to acknowledge"]
    #[doc = " @return ResultOk if the message was successfully acknowledged"]
    #[doc = " @return ResultError if there was a failure"]
    pub fn pulsar_consumer_acknowledge(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " Asynchronously acknowledge the reception of a single message."]
    #[doc = ""]
    #[doc = " This method will initiate the operation and return immediately. The provided callback"]
    #[doc = " will be triggered when the operation is complete."]
    #[doc = ""]
    #[doc = " @param message the message to acknowledge"]
    #[doc = " @param callback callback that will be triggered when the message has been acknowledged"]
    pub fn pulsar_consumer_acknowledge_async(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_async_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Acknowledge the reception of all the messages in the stream up to (and including)"]
    #[doc = " the provided message."]
    #[doc = ""]
    #[doc = " This method will block until an acknowledgement is sent to the broker. After"]
    #[doc = " that, the messages will not be re-delivered to this consumer."]
    #[doc = ""]
    #[doc = " Cumulative acknowledge cannot be used when the consumer type is set to ConsumerShared."]
    #[doc = ""]
    #[doc = " It's equivalent to calling asyncAcknowledgeCumulative(const Message&, ResultCallback) and"]
    #[doc = " waiting for the callback to be triggered."]
    #[doc = ""]
    #[doc = " @param message the last message in the stream to acknowledge"]
    #[doc = " @return ResultOk if the message was successfully acknowledged. All previously delivered messages for"]
    #[doc = " this topic are also acknowledged."]
    #[doc = " @return ResultError if there was a failure"]
    pub fn pulsar_consumer_acknowledge_cumulative(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " Asynchronously acknowledge the reception of all the messages in the stream up to (and"]
    #[doc = " including) the provided message."]
    #[doc = ""]
    #[doc = " This method will initiate the operation and return immediately. The provided callback"]
    #[doc = " will be triggered when the operation is complete."]
    #[doc = ""]
    #[doc = " @param message the message to acknowledge"]
    #[doc = " @param callback callback that will be triggered when the message has been acknowledged"]
    pub fn pulsar_consumer_acknowledge_cumulative_async(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative_async_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Acknowledge the failure to process a single message."]
    #[doc = " <p>"]
    #[doc = " When a message is \"negatively acked\" it will be marked for redelivery after"]
    #[doc = " some fixed delay. The delay is configurable when constructing the consumer"]
    #[doc = " with {@link ConsumerConfiguration#setNegativeAckRedeliveryDelayMs}."]
    #[doc = " <p>"]
    #[doc = " This call is not blocking."]
    #[doc = ""]
    #[doc = " @param message"]
    #[doc = "            The {@code Message} to be acknowledged"]
    pub fn pulsar_consumer_negative_acknowledge(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    );
}
extern "C" {
    #[doc = " Acknowledge the failure to process a single message through its message id"]
    #[doc = " <p>"]
    #[doc = " When a message is \"negatively acked\" it will be marked for redelivery after"]
    #[doc = " some fixed delay. The delay is configurable when constructing the consumer"]
    #[doc = " with {@link ConsumerConfiguration#setNegativeAckRedeliveryDelayMs}."]
    #[doc = " <p>"]
    #[doc = " This call is not blocking."]
    #[doc = ""]
    #[doc = " @param message"]
    #[doc = "            The message id to be acknowledged"]
    pub fn pulsar_consumer_negative_acknowledge_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    );
}
extern "C" {
    pub fn pulsar_consumer_close(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_close_async(
        consumer: *mut pulsar_consumer_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_free(consumer: *mut pulsar_consumer_t);
}
extern "C" {
    pub fn pulsar_consumer_pause_message_listener(
        consumer: *mut pulsar_consumer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn resume_message_listener(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    #[doc = " Redelivers all the unacknowledged messages. In Failover mode, the request is ignored if the consumer is"]
    #[doc = " not"]
    #[doc = " active for the given topic. In Shared mode, the consumers messages to be redelivered are distributed"]
    #[doc = " across all"]
    #[doc = " the connected consumers. This is a non blocking call and doesn't throw an exception. In case the"]
    #[doc = " connection"]
    #[doc = " breaks, the messages are redelivered after reconnect."]
    pub fn pulsar_consumer_redeliver_unacknowledged_messages(consumer: *mut pulsar_consumer_t);
}
extern "C" {
    pub fn pulsar_consumer_seek_async(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_seek(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_reader {
    _unused: [u8; 0],
}
pub type pulsar_reader_t = _pulsar_reader;
extern "C" {
    #[doc = " @return the topic this reader is reading from"]
    pub fn pulsar_reader_get_topic(reader: *mut pulsar_reader_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a single message."]
    #[doc = ""]
    #[doc = " If a message is not immediately available, this method will block until a new"]
    #[doc = " message is available."]
    #[doc = ""]
    #[doc = " @param msg a non-const reference where the received message will be copied"]
    #[doc = " @return ResultOk when a message is received"]
    #[doc = " @return ResultInvalidConfiguration if a message listener had been set in the configuration"]
    pub fn pulsar_reader_read_next(
        reader: *mut pulsar_reader_t,
        msg: *mut *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    #[doc = " Read a single message"]
    #[doc = ""]
    #[doc = " @param msg a non-const reference where the received message will be copied"]
    #[doc = " @param timeoutMs the receive timeout in milliseconds"]
    #[doc = " @return ResultOk if a message was received"]
    #[doc = " @return ResultTimeout if the receive timeout was triggered"]
    #[doc = " @return ResultInvalidConfiguration if a message listener had been set in the configuration"]
    pub fn pulsar_reader_read_next_with_timeout(
        reader: *mut pulsar_reader_t,
        msg: *mut *mut pulsar_message_t,
        timeoutMs: ::std::os::raw::c_int,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_reader_close(reader: *mut pulsar_reader_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_reader_close_async(
        reader: *mut pulsar_reader_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_reader_free(reader: *mut pulsar_reader_t);
}
extern "C" {
    pub fn pulsar_reader_has_message_available(
        reader: *mut pulsar_reader_t,
        available: *mut ::std::os::raw::c_int,
    ) -> pulsar_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_topic_metadata {
    _unused: [u8; 0],
}
pub type pulsar_topic_metadata_t = _pulsar_topic_metadata;
pub type pulsar_message_router = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *mut pulsar_message_t,
        topicMetadata: *mut pulsar_topic_metadata_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pulsar_topic_metadata_get_num_partitions(
        topicMetadata: *mut pulsar_topic_metadata_t,
    ) -> ::std::os::raw::c_int;
}
pub const pulsar_partitions_routing_mode_pulsar_UseSinglePartition: pulsar_partitions_routing_mode =
    0;
pub const pulsar_partitions_routing_mode_pulsar_RoundRobinDistribution:
    pulsar_partitions_routing_mode = 1;
pub const pulsar_partitions_routing_mode_pulsar_CustomPartition: pulsar_partitions_routing_mode = 2;
pub type pulsar_partitions_routing_mode = u32;
pub const pulsar_hashing_scheme_pulsar_Murmur3_32Hash: pulsar_hashing_scheme = 0;
pub const pulsar_hashing_scheme_pulsar_BoostHash: pulsar_hashing_scheme = 1;
pub const pulsar_hashing_scheme_pulsar_JavaStringHash: pulsar_hashing_scheme = 2;
pub type pulsar_hashing_scheme = u32;
pub const pulsar_compression_type_pulsar_CompressionNone: pulsar_compression_type = 0;
pub const pulsar_compression_type_pulsar_CompressionLZ4: pulsar_compression_type = 1;
pub const pulsar_compression_type_pulsar_CompressionZLib: pulsar_compression_type = 2;
pub type pulsar_compression_type = u32;
pub const pulsar_schema_type_pulsar_None: pulsar_schema_type = 0;
pub const pulsar_schema_type_pulsar_String: pulsar_schema_type = 1;
pub const pulsar_schema_type_pulsar_Json: pulsar_schema_type = 2;
pub const pulsar_schema_type_pulsar_Protobuf: pulsar_schema_type = 3;
pub const pulsar_schema_type_pulsar_Avro: pulsar_schema_type = 4;
pub const pulsar_schema_type_pulsar_Boolean: pulsar_schema_type = 5;
pub const pulsar_schema_type_pulsar_Int8: pulsar_schema_type = 6;
pub const pulsar_schema_type_pulsar_Int16: pulsar_schema_type = 7;
pub const pulsar_schema_type_pulsar_Int32: pulsar_schema_type = 8;
pub const pulsar_schema_type_pulsar_Int64: pulsar_schema_type = 9;
pub const pulsar_schema_type_pulsar_Float32: pulsar_schema_type = 10;
pub const pulsar_schema_type_pulsar_Float64: pulsar_schema_type = 11;
pub const pulsar_schema_type_pulsar_KeyValue: pulsar_schema_type = 15;
pub const pulsar_schema_type_pulsar_Bytes: pulsar_schema_type = -1;
pub const pulsar_schema_type_pulsar_AutoConsume: pulsar_schema_type = -3;
pub const pulsar_schema_type_pulsar_AutoPublish: pulsar_schema_type = -4;
pub type pulsar_schema_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_producer_configuration {
    _unused: [u8; 0],
}
pub type pulsar_producer_configuration_t = _pulsar_producer_configuration;
extern "C" {
    pub fn pulsar_producer_configuration_create() -> *mut pulsar_producer_configuration_t;
}
extern "C" {
    pub fn pulsar_producer_configuration_free(conf: *mut pulsar_producer_configuration_t);
}
extern "C" {
    pub fn pulsar_producer_configuration_set_producer_name(
        conf: *mut pulsar_producer_configuration_t,
        producerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_producer_name(
        conf: *mut pulsar_producer_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_send_timeout(
        conf: *mut pulsar_producer_configuration_t,
        sendTimeoutMs: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_send_timeout(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_initial_sequence_id(
        conf: *mut pulsar_producer_configuration_t,
        initialSequenceId: i64,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_initial_sequence_id(
        conf: *mut pulsar_producer_configuration_t,
    ) -> i64;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_compression_type(
        conf: *mut pulsar_producer_configuration_t,
        compressionType: pulsar_compression_type,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_compression_type(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_compression_type;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_schema_info(
        conf: *mut pulsar_producer_configuration_t,
        schemaType: pulsar_schema_type,
        name: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        properties: *mut pulsar_string_map_t,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_set_max_pending_messages(
        conf: *mut pulsar_producer_configuration_t,
        maxPendingMessages: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_max_pending_messages(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of max pending messages across all the partitions"]
    #[doc = " <p>"]
    #[doc = " This setting will be used to lower the max pending messages for each partition"]
    #[doc = " ({@link #setMaxPendingMessages(int)}), if the total exceeds the configured value."]
    #[doc = ""]
    #[doc = " @param maxPendingMessagesAcrossPartitions"]
    pub fn pulsar_producer_configuration_set_max_pending_messages_across_partitions(
        conf: *mut pulsar_producer_configuration_t,
        maxPendingMessagesAcrossPartitions: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the maximum number of pending messages allowed across all the partitions"]
    pub fn pulsar_producer_configuration_get_max_pending_messages_across_partitions(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_partitions_routing_mode(
        conf: *mut pulsar_producer_configuration_t,
        mode: pulsar_partitions_routing_mode,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_partitions_routing_mode(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_partitions_routing_mode;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_message_router(
        conf: *mut pulsar_producer_configuration_t,
        router: pulsar_message_router,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_set_hashing_scheme(
        conf: *mut pulsar_producer_configuration_t,
        scheme: pulsar_hashing_scheme,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_hashing_scheme(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_hashing_scheme;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_block_if_queue_full(
        conf: *mut pulsar_producer_configuration_t,
        blockIfQueueFull: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_block_if_queue_full(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_enabled(
        conf: *mut pulsar_producer_configuration_t,
        batchingEnabled: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_enabled(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_messages(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxMessages: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_messages(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_allowed_size_in_bytes(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxAllowedSizeInBytes: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_allowed_size_in_bytes(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_publish_delay_ms(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxPublishDelayMs: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_publish_delay_ms(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_property(
        conf: *mut pulsar_producer_configuration_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_consumer_configuration {
    _unused: [u8; 0],
}
pub type pulsar_consumer_configuration_t = _pulsar_consumer_configuration;
#[doc = " There can be only 1 consumer on the same topic with the same consumerName"]
pub const pulsar_consumer_type_pulsar_ConsumerExclusive: pulsar_consumer_type = 0;
#[doc = " Multiple consumers will be able to use the same consumerName and the messages"]
#[doc = "  will be dispatched according to a round-robin rotation between the connected consumers"]
pub const pulsar_consumer_type_pulsar_ConsumerShared: pulsar_consumer_type = 1;
#[doc = " Only one consumer is active on the subscription; Subscription can have N consumers"]
#[doc = "  connected one of which will get promoted to master if the current master becomes inactive"]
pub const pulsar_consumer_type_pulsar_ConsumerFailover: pulsar_consumer_type = 2;
#[doc = " Multiple consumer will be able to use the same subscription and all messages with the same key"]
#[doc = " will be dispatched to only one consumer"]
pub const pulsar_consumer_type_pulsar_ConsumerKeyShared: pulsar_consumer_type = 3;
pub type pulsar_consumer_type = u32;
#[doc = " the latest position which means the start consuming position will be the last message"]
pub const initial_position_initial_position_latest: initial_position = 0;
#[doc = " the earliest position which means the start consuming position will be the first message"]
pub const initial_position_initial_position_earliest: initial_position = 1;
pub type initial_position = u32;
#[doc = " Callback definition for MessageListener"]
pub type pulsar_message_listener = ::std::option::Option<
    unsafe extern "C" fn(
        consumer: *mut pulsar_consumer_t,
        msg: *mut pulsar_message_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn pulsar_consumer_configuration_create() -> *mut pulsar_consumer_configuration_t;
}
extern "C" {
    pub fn pulsar_consumer_configuration_free(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    );
}
extern "C" {
    #[doc = " Specify the consumer type. The consumer type enables"]
    #[doc = " specifying the type of subscription. In Exclusive subscription,"]
    #[doc = " only a single consumer is allowed to attach to the subscription. Other consumers"]
    #[doc = " will get an error message. In Shared subscription, multiple consumers will be"]
    #[doc = " able to use the same subscription name and the messages will be dispatched in a"]
    #[doc = " round robin fashion. In Failover subscription, a primary-failover subscription model"]
    #[doc = " allows for multiple consumers to attach to a single subscription, though only one"]
    #[doc = " of them will be \u{201c}master\u{201d} at a given time. Only the primary consumer will receive"]
    #[doc = " messages. When the primary consumer gets disconnected, one among the failover"]
    #[doc = " consumers will be promoted to primary and will start getting messages."]
    pub fn pulsar_consumer_configuration_set_consumer_type(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        consumerType: pulsar_consumer_type,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_get_consumer_type(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> pulsar_consumer_type;
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_schema_info(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        schemaType: pulsar_schema_type,
        name: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        properties: *mut pulsar_string_map_t,
    );
}
extern "C" {
    #[doc = " A message listener enables your application to configure how to process"]
    #[doc = " and acknowledge messages delivered. A listener will be called in order"]
    #[doc = " for every message received."]
    pub fn pulsar_consumer_configuration_set_message_listener(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        messageListener: pulsar_message_listener,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_has_message_listener(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the size of the consumer receive queue."]
    #[doc = ""]
    #[doc = " The consumer receive queue controls how many messages can be accumulated by the Consumer before the"]
    #[doc = " application calls receive(). Using a higher value could potentially increase the consumer throughput"]
    #[doc = " at the expense of bigger memory utilization."]
    #[doc = ""]
    #[doc = " Setting the consumer queue size as zero decreases the throughput of the consumer, by disabling"]
    #[doc = " pre-fetching of"]
    #[doc = " messages. This approach improves the message distribution on shared subscription, by pushing messages"]
    #[doc = " only to"]
    #[doc = " the consumers that are ready to process them. Neither receive with timeout nor Partitioned Topics can"]
    #[doc = " be"]
    #[doc = " used if the consumer queue size is zero. The receive() function call should not be interrupted when"]
    #[doc = " the consumer queue size is zero."]
    #[doc = ""]
    #[doc = " Default value is 1000 messages and should be good for most use cases."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "            the new receiver queue size value"]
    pub fn pulsar_consumer_configuration_set_receiver_queue_size(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_get_receiver_queue_size(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the max total receiver queue size across partitons."]
    #[doc = " <p>"]
    #[doc = " This setting will be used to reduce the receiver queue size for individual partitions"]
    #[doc = " {@link #setReceiverQueueSize(int)} if the total exceeds this value (default: 50000)."]
    #[doc = ""]
    #[doc = " @param maxTotalReceiverQueueSizeAcrossPartitions"]
    pub fn pulsar_consumer_set_max_total_receiver_queue_size_across_partitions(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        maxTotalReceiverQueueSizeAcrossPartitions: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @return the configured max total receiver queue size across partitions"]
    pub fn pulsar_consumer_get_max_total_receiver_queue_size_across_partitions(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_consumer_name(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        consumerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_consumer_name(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the timeout in milliseconds for unacknowledged messages, the timeout needs to be greater than"]
    #[doc = " 10 seconds. An Exception is thrown if the given value is less than 10000 (10 seconds)."]
    #[doc = " If a successful acknowledgement is not sent within the timeout all the unacknowledged messages are"]
    #[doc = " redelivered."]
    #[doc = " @param timeout in milliseconds"]
    pub fn pulsar_consumer_set_unacked_messages_timeout_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        milliSeconds: u64,
    );
}
extern "C" {
    #[doc = " @return the configured timeout in milliseconds for unacked messages."]
    pub fn pulsar_consumer_get_unacked_messages_timeout_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Set the delay to wait before re-delivering messages that have failed to be process."]
    #[doc = " <p>"]
    #[doc = " When application uses {@link Consumer#negativeAcknowledge(Message)}, the failed message"]
    #[doc = " will be redelivered after a fixed timeout. The default is 1 min."]
    #[doc = ""]
    #[doc = " @param redeliveryDelay"]
    #[doc = "            redelivery delay for failed messages"]
    #[doc = " @param timeUnit"]
    #[doc = "            unit in which the timeout is provided."]
    #[doc = " @return the consumer builder instance"]
    pub fn pulsar_configure_set_negative_ack_redelivery_delay_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        redeliveryDelayMillis: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[doc = " Get the configured delay to wait before re-delivering messages that have failed to be process."]
    #[doc = ""]
    #[doc = " @param consumer_configuration the consumer conf object"]
    #[doc = " @return redelivery delay for failed messages"]
    pub fn pulsar_configure_get_negative_ack_redelivery_delay_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pulsar_consumer_is_encryption_enabled(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_is_read_compacted(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_read_compacted(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        compacted: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_subscription_initial_position(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_subscription_initial_position(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        subscriptionInitialPosition: initial_position,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_property(
        conf: *mut pulsar_consumer_configuration_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_reader_configuration {
    _unused: [u8; 0],
}
pub type pulsar_reader_configuration_t = _pulsar_reader_configuration;
pub type pulsar_reader_listener = ::std::option::Option<
    unsafe extern "C" fn(
        reader: *mut pulsar_reader_t,
        msg: *mut pulsar_message_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn pulsar_reader_configuration_create() -> *mut pulsar_reader_configuration_t;
}
extern "C" {
    pub fn pulsar_reader_configuration_free(configuration: *mut pulsar_reader_configuration_t);
}
extern "C" {
    #[doc = " A message listener enables your application to configure how to process"]
    #[doc = " messages. A listener will be called in order for every message received."]
    pub fn pulsar_reader_configuration_set_reader_listener(
        configuration: *mut pulsar_reader_configuration_t,
        listener: pulsar_reader_listener,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_has_reader_listener(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the size of the reader receive queue."]
    #[doc = ""]
    #[doc = " The consumer receive queue controls how many messages can be accumulated by the Consumer before the"]
    #[doc = " application calls receive(). Using a higher value could potentially increase the consumer throughput"]
    #[doc = " at the expense of bigger memory utilization."]
    #[doc = ""]
    #[doc = " Setting the consumer queue size as zero decreases the throughput of the consumer, by disabling"]
    #[doc = " pre-fetching of"]
    #[doc = " messages. This approach improves the message distribution on shared subscription, by pushing messages"]
    #[doc = " only to"]
    #[doc = " the consumers that are ready to process them. Neither receive with timeout nor Partitioned Topics can"]
    #[doc = " be"]
    #[doc = " used if the consumer queue size is zero. The receive() function call should not be interrupted when"]
    #[doc = " the consumer queue size is zero."]
    #[doc = ""]
    #[doc = " Default value is 1000 messages and should be good for most use cases."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "            the new receiver queue size value"]
    pub fn pulsar_reader_configuration_set_receiver_queue_size(
        configuration: *mut pulsar_reader_configuration_t,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_receiver_queue_size(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_reader_name(
        configuration: *mut pulsar_reader_configuration_t,
        readerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_reader_name(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_subscription_role_prefix(
        configuration: *mut pulsar_reader_configuration_t,
        subscriptionRolePrefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_subscription_role_prefix(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_read_compacted(
        configuration: *mut pulsar_reader_configuration_t,
        readCompacted: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_is_read_compacted(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_string_list {
    _unused: [u8; 0],
}
pub type pulsar_string_list_t = _pulsar_string_list;
extern "C" {
    pub fn pulsar_string_list_create() -> *mut pulsar_string_list_t;
}
extern "C" {
    pub fn pulsar_string_list_free(list: *mut pulsar_string_list_t);
}
extern "C" {
    pub fn pulsar_string_list_size(list: *mut pulsar_string_list_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_string_list_append(
        list: *mut pulsar_string_list_t,
        item: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_string_list_get(
        map: *mut pulsar_string_list_t,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_client {
    _unused: [u8; 0],
}
pub type pulsar_client_t = _pulsar_client;
pub type pulsar_create_producer_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        producer: *mut pulsar_producer_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_subscribe_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        consumer: *mut pulsar_consumer_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_reader_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        reader: *mut pulsar_reader_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_get_partitions_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        partitions: *mut pulsar_string_list_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a Pulsar client object connecting to the specified cluster address and using the specified"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " @param serviceUrl the Pulsar endpoint to use (eg: pulsar://broker-example.com:6650)"]
    #[doc = " @param clientConfiguration the client configuration to use"]
    pub fn pulsar_client_create(
        serviceUrl: *const ::std::os::raw::c_char,
        clientConfiguration: *const pulsar_client_configuration_t,
    ) -> *mut pulsar_client_t;
}
extern "C" {
    #[doc = " Create a producer with default configuration"]
    #[doc = ""]
    #[doc = " @see createProducer(const std::string&, const ProducerConfiguration&, Producer&)"]
    #[doc = ""]
    #[doc = " @param topic the topic where the new producer will publish"]
    #[doc = " @param producer a non-const reference where the new producer will be copied"]
    #[doc = " @return ResultOk if the producer has been successfully created"]
    #[doc = " @return ResultError if there was an error"]
    pub fn pulsar_client_create_producer(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        conf: *const pulsar_producer_configuration_t,
        producer: *mut *mut pulsar_producer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_create_producer_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        conf: *const pulsar_producer_configuration_t,
        callback: pulsar_create_producer_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        consumer: *mut *mut pulsar_consumer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_subscribe_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe_multi_topics_async(
        client: *mut pulsar_client_t,
        topics: *mut *const ::std::os::raw::c_char,
        topicsCount: ::std::os::raw::c_int,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe_pattern_async(
        client: *mut pulsar_client_t,
        topicPattern: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Create a topic reader with given {@code ReaderConfiguration} for reading messages from the specified"]
    #[doc = " topic."]
    #[doc = " <p>"]
    #[doc = " The Reader provides a low-level abstraction that allows for manual positioning in the topic, without"]
    #[doc = " using a"]
    #[doc = " subscription. Reader can only work on non-partitioned topics."]
    #[doc = " <p>"]
    #[doc = " The initial reader positioning is done by specifying a message id. The options are:"]
    #[doc = " <ul>"]
    #[doc = " <li><code>MessageId.earliest</code> : Start reading from the earliest message available in the topic"]
    #[doc = " <li><code>MessageId.latest</code> : Start reading from the end topic, only getting messages published"]
    #[doc = " after the"]
    #[doc = " reader was created"]
    #[doc = " <li><code>MessageId</code> : When passing a particular message id, the reader will position itself on"]
    #[doc = " that"]
    #[doc = " specific position. The first message to be read will be the message next to the specified messageId."]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param topic"]
    #[doc = "            The name of the topic where to read"]
    #[doc = " @param startMessageId"]
    #[doc = "            The message id where the reader will position itself. The first message returned will be the"]
    #[doc = " one after"]
    #[doc = "            the specified startMessageId"]
    #[doc = " @param conf"]
    #[doc = "            The {@code ReaderConfiguration} object"]
    #[doc = " @return The {@code Reader} object"]
    pub fn pulsar_client_create_reader(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        startMessageId: *const pulsar_message_id_t,
        conf: *mut pulsar_reader_configuration_t,
        reader: *mut *mut pulsar_reader_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_create_reader_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        startMessageId: *const pulsar_message_id_t,
        conf: *mut pulsar_reader_configuration_t,
        callback: pulsar_reader_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_get_topic_partitions(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        partitions: *mut *mut pulsar_string_list_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_get_topic_partitions_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        callback: pulsar_get_partitions_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_close(client: *mut pulsar_client_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_close_async(
        client: *mut pulsar_client_t,
        callback: pulsar_close_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_free(client: *mut pulsar_client_t);
}
