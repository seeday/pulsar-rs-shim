/* automatically generated by rust-bindgen */
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_authentication {
    _unused: [u8; 0],
}
pub type pulsar_authentication_t = _pulsar_authentication;
pub type token_supplier = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn pulsar_authentication_create(
        dynamicLibPath: *const ::std::os::raw::c_char,
        authParamsString: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_tls_create(
        certificatePath: *const ::std::os::raw::c_char,
        privateKeyPath: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_token_create(
        token: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_token_create_with_supplier(
        tokenSupplier: token_supplier,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_athenz_create(
        authParamsString: *const ::std::os::raw::c_char,
    ) -> *mut pulsar_authentication_t;
}
extern "C" {
    pub fn pulsar_authentication_free(authentication: *mut pulsar_authentication_t);
}
pub const pulsar_logger_level_t_pulsar_DEBUG: pulsar_logger_level_t = 0;
pub const pulsar_logger_level_t_pulsar_INFO: pulsar_logger_level_t = 1;
pub const pulsar_logger_level_t_pulsar_WARN: pulsar_logger_level_t = 2;
pub const pulsar_logger_level_t_pulsar_ERROR: pulsar_logger_level_t = 3;
pub type pulsar_logger_level_t = u32;
pub type pulsar_logger = ::std::option::Option<
    unsafe extern "C" fn(
        level: pulsar_logger_level_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_client_configuration {
    _unused: [u8; 0],
}
pub type pulsar_client_configuration_t = _pulsar_client_configuration;
extern "C" {
    pub fn pulsar_client_configuration_create() -> *mut pulsar_client_configuration_t;
}
extern "C" {
    pub fn pulsar_client_configuration_free(conf: *mut pulsar_client_configuration_t);
}
extern "C" {
    pub fn pulsar_client_configuration_set_auth(
        conf: *mut pulsar_client_configuration_t,
        authentication: *mut pulsar_authentication_t,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_set_operation_timeout_seconds(
        conf: *mut pulsar_client_configuration_t,
        timeout: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_operation_timeout_seconds(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_io_threads(
        conf: *mut pulsar_client_configuration_t,
        threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_io_threads(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_message_listener_threads(
        conf: *mut pulsar_client_configuration_t,
        threads: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_message_listener_threads(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_concurrent_lookup_request(
        conf: *mut pulsar_client_configuration_t,
        concurrentLookupRequest: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_concurrent_lookup_request(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_logger(
        conf: *mut pulsar_client_configuration_t,
        logger: pulsar_logger,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_set_use_tls(
        conf: *mut pulsar_client_configuration_t,
        useTls: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_use_tls(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_tls_trust_certs_file_path(
        conf: *mut pulsar_client_configuration_t,
        tlsTrustCertsFilePath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_tls_trust_certs_file_path(
        conf: *mut pulsar_client_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_client_configuration_set_tls_allow_insecure_connection(
        conf: *mut pulsar_client_configuration_t,
        allowInsecure: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_tls_allow_insecure_connection(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_stats_interval_in_seconds(
        conf: *mut pulsar_client_configuration_t,
        interval: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_is_validate_hostname(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_client_configuration_set_validate_hostname(
        conf: *mut pulsar_client_configuration_t,
        validateHostName: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_client_configuration_get_stats_interval_in_seconds(
        conf: *mut pulsar_client_configuration_t,
    ) -> ::std::os::raw::c_uint;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_string_map {
    _unused: [u8; 0],
}
pub type pulsar_string_map_t = _pulsar_string_map;
extern "C" {
    pub fn pulsar_string_map_create() -> *mut pulsar_string_map_t;
}
extern "C" {
    pub fn pulsar_string_map_free(map: *mut pulsar_string_map_t);
}
extern "C" {
    pub fn pulsar_string_map_size(map: *mut pulsar_string_map_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_string_map_put(
        map: *mut pulsar_string_map_t,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_string_map_get(
        map: *mut pulsar_string_map_t,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_string_map_get_key(
        map: *mut pulsar_string_map_t,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_string_map_get_value(
        map: *mut pulsar_string_map_t,
        idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_message {
    _unused: [u8; 0],
}
pub type pulsar_message_t = _pulsar_message;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_message_id {
    _unused: [u8; 0],
}
pub type pulsar_message_id_t = _pulsar_message_id;
extern "C" {
    pub fn pulsar_message_create() -> *mut pulsar_message_t;
}
extern "C" {
    pub fn pulsar_message_free(message: *mut pulsar_message_t);
}
extern "C" {
    pub fn pulsar_message_set_content(
        message: *mut pulsar_message_t,
        data: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn pulsar_message_set_allocated_content(
        message: *mut pulsar_message_t,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    pub fn pulsar_message_set_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_message_set_partition_key(
        message: *mut pulsar_message_t,
        partitionKey: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_message_set_ordering_key(
        message: *mut pulsar_message_t,
        orderingKey: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_message_set_event_timestamp(message: *mut pulsar_message_t, eventTimestamp: u64);
}
extern "C" {
    pub fn pulsar_message_set_sequence_id(message: *mut pulsar_message_t, sequenceId: i64);
}
extern "C" {
    pub fn pulsar_message_set_deliver_after(message: *mut pulsar_message_t, delayMillis: u64);
}
extern "C" {
    pub fn pulsar_message_set_deliver_at(
        message: *mut pulsar_message_t,
        deliveryTimestampMillis: u64,
    );
}
extern "C" {
    pub fn pulsar_message_set_replication_clusters(
        message: *mut pulsar_message_t,
        clusters: *mut *const ::std::os::raw::c_char,
        size: usize,
    );
}
extern "C" {
    pub fn pulsar_message_disable_replication(
        message: *mut pulsar_message_t,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_message_get_properties(
        message: *mut pulsar_message_t,
    ) -> *mut pulsar_string_map_t;
}
extern "C" {
    pub fn pulsar_message_has_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_message_get_property(
        message: *mut pulsar_message_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_get_data(message: *mut pulsar_message_t)
        -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn pulsar_message_get_length(message: *mut pulsar_message_t) -> u32;
}
extern "C" {
    pub fn pulsar_message_get_message_id(
        message: *mut pulsar_message_t,
    ) -> *mut pulsar_message_id_t;
}
extern "C" {
    pub fn pulsar_message_get_partitionKey(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_has_partition_key(
        message: *mut pulsar_message_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_message_get_orderingKey(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_has_ordering_key(message: *mut pulsar_message_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_message_get_publish_timestamp(message: *mut pulsar_message_t) -> u64;
}
extern "C" {
    pub fn pulsar_message_get_event_timestamp(message: *mut pulsar_message_t) -> u64;
}
extern "C" {
    pub fn pulsar_message_get_topic_name(
        message: *mut pulsar_message_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_get_redelivery_count(
        message: *mut pulsar_message_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_message_id_earliest() -> *const pulsar_message_id_t;
}
extern "C" {
    pub fn pulsar_message_id_latest() -> *const pulsar_message_id_t;
}
extern "C" {
    pub fn pulsar_message_id_serialize(
        messageId: *mut pulsar_message_id_t,
        len: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pulsar_message_id_deserialize(
        buffer: *const ::std::os::raw::c_void,
        len: u32,
    ) -> *mut pulsar_message_id_t;
}
extern "C" {
    pub fn pulsar_message_id_str(
        messageId: *mut pulsar_message_id_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_message_id_free(messageId: *mut pulsar_message_id_t);
}
pub const pulsar_result_pulsar_result_Ok: pulsar_result = 0;
pub const pulsar_result_pulsar_result_UnknownError: pulsar_result = 1;
pub const pulsar_result_pulsar_result_InvalidConfiguration: pulsar_result = 2;
pub const pulsar_result_pulsar_result_Timeout: pulsar_result = 3;
pub const pulsar_result_pulsar_result_LookupError: pulsar_result = 4;
pub const pulsar_result_pulsar_result_ConnectError: pulsar_result = 5;
pub const pulsar_result_pulsar_result_ReadError: pulsar_result = 6;
pub const pulsar_result_pulsar_result_AuthenticationError: pulsar_result = 7;
pub const pulsar_result_pulsar_result_AuthorizationError: pulsar_result = 8;
pub const pulsar_result_pulsar_result_ErrorGettingAuthenticationData: pulsar_result = 9;
pub const pulsar_result_pulsar_result_BrokerMetadataError: pulsar_result = 10;
pub const pulsar_result_pulsar_result_BrokerPersistenceError: pulsar_result = 11;
pub const pulsar_result_pulsar_result_ChecksumError: pulsar_result = 12;
pub const pulsar_result_pulsar_result_ConsumerBusy: pulsar_result = 13;
pub const pulsar_result_pulsar_result_NotConnected: pulsar_result = 14;
pub const pulsar_result_pulsar_result_AlreadyClosed: pulsar_result = 15;
pub const pulsar_result_pulsar_result_InvalidMessage: pulsar_result = 16;
pub const pulsar_result_pulsar_result_ConsumerNotInitialized: pulsar_result = 17;
pub const pulsar_result_pulsar_result_ProducerNotInitialized: pulsar_result = 18;
pub const pulsar_result_pulsar_result_TooManyLookupRequestException: pulsar_result = 19;
pub const pulsar_result_pulsar_result_InvalidTopicName: pulsar_result = 20;
pub const pulsar_result_pulsar_result_InvalidUrl: pulsar_result = 21;
pub const pulsar_result_pulsar_result_ServiceUnitNotReady: pulsar_result = 22;
pub const pulsar_result_pulsar_result_OperationNotSupported: pulsar_result = 23;
pub const pulsar_result_pulsar_result_ProducerBlockedQuotaExceededError: pulsar_result = 24;
pub const pulsar_result_pulsar_result_ProducerBlockedQuotaExceededException: pulsar_result = 25;
pub const pulsar_result_pulsar_result_ProducerQueueIsFull: pulsar_result = 26;
pub const pulsar_result_pulsar_result_MessageTooBig: pulsar_result = 27;
pub const pulsar_result_pulsar_result_TopicNotFound: pulsar_result = 28;
pub const pulsar_result_pulsar_result_SubscriptionNotFound: pulsar_result = 29;
pub const pulsar_result_pulsar_result_ConsumerNotFound: pulsar_result = 30;
pub const pulsar_result_pulsar_result_UnsupportedVersionError: pulsar_result = 31;
pub const pulsar_result_pulsar_result_TopicTerminated: pulsar_result = 32;
pub const pulsar_result_pulsar_result_CryptoError: pulsar_result = 33;
pub type pulsar_result = u32;
extern "C" {
    pub fn pulsar_result_str(result: pulsar_result) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_producer {
    _unused: [u8; 0],
}
pub type pulsar_producer_t = _pulsar_producer;
pub type pulsar_send_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: pulsar_result,
        msgId: *mut pulsar_message_id_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_close_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, ctx: *mut ::std::os::raw::c_void),
>;
pub type pulsar_flush_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, ctx: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn pulsar_producer_get_topic(
        producer: *mut pulsar_producer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_producer_get_producer_name(
        producer: *mut pulsar_producer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_producer_send(
        producer: *mut pulsar_producer_t,
        msg: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_producer_send_async(
        producer: *mut pulsar_producer_t,
        msg: *mut pulsar_message_t,
        callback: pulsar_send_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_get_last_sequence_id(producer: *mut pulsar_producer_t) -> i64;
}
extern "C" {
    pub fn pulsar_producer_close(producer: *mut pulsar_producer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_producer_close_async(
        producer: *mut pulsar_producer_t,
        callback: pulsar_close_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_flush(producer: *mut pulsar_producer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_producer_flush_async(
        producer: *mut pulsar_producer_t,
        callback: pulsar_flush_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_free(producer: *mut pulsar_producer_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_consumer {
    _unused: [u8; 0],
}
pub type pulsar_consumer_t = _pulsar_consumer;
pub type pulsar_result_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: pulsar_result, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn pulsar_consumer_get_topic(
        consumer: *mut pulsar_consumer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_consumer_get_subscription_name(
        consumer: *mut pulsar_consumer_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_consumer_unsubscribe(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_unsubscribe_async(
        consumer: *mut pulsar_consumer_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_receive(
        consumer: *mut pulsar_consumer_t,
        msg: *mut *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_receive_with_timeout(
        consumer: *mut pulsar_consumer_t,
        msg: *mut *mut pulsar_message_t,
        timeoutMs: ::std::os::raw::c_int,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_async(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_async_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative_async(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_acknowledge_cumulative_async_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_negative_acknowledge(
        consumer: *mut pulsar_consumer_t,
        message: *mut pulsar_message_t,
    );
}
extern "C" {
    pub fn pulsar_consumer_negative_acknowledge_id(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    );
}
extern "C" {
    pub fn pulsar_consumer_close(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_close_async(
        consumer: *mut pulsar_consumer_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_free(consumer: *mut pulsar_consumer_t);
}
extern "C" {
    pub fn pulsar_consumer_pause_message_listener(
        consumer: *mut pulsar_consumer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn resume_message_listener(consumer: *mut pulsar_consumer_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_consumer_redeliver_unacknowledged_messages(consumer: *mut pulsar_consumer_t);
}
extern "C" {
    pub fn pulsar_consumer_seek_async(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_seek(
        consumer: *mut pulsar_consumer_t,
        messageId: *mut pulsar_message_id_t,
    ) -> pulsar_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_reader {
    _unused: [u8; 0],
}
pub type pulsar_reader_t = _pulsar_reader;
extern "C" {
    pub fn pulsar_reader_get_topic(reader: *mut pulsar_reader_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_reader_read_next(
        reader: *mut pulsar_reader_t,
        msg: *mut *mut pulsar_message_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_reader_read_next_with_timeout(
        reader: *mut pulsar_reader_t,
        msg: *mut *mut pulsar_message_t,
        timeoutMs: ::std::os::raw::c_int,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_reader_close(reader: *mut pulsar_reader_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_reader_close_async(
        reader: *mut pulsar_reader_t,
        callback: pulsar_result_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_reader_free(reader: *mut pulsar_reader_t);
}
extern "C" {
    pub fn pulsar_reader_has_message_available(
        reader: *mut pulsar_reader_t,
        available: *mut ::std::os::raw::c_int,
    ) -> pulsar_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_topic_metadata {
    _unused: [u8; 0],
}
pub type pulsar_topic_metadata_t = _pulsar_topic_metadata;
pub type pulsar_message_router = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *mut pulsar_message_t,
        topicMetadata: *mut pulsar_topic_metadata_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pulsar_topic_metadata_get_num_partitions(
        topicMetadata: *mut pulsar_topic_metadata_t,
    ) -> ::std::os::raw::c_int;
}
pub const pulsar_partitions_routing_mode_pulsar_UseSinglePartition: pulsar_partitions_routing_mode =
    0;
pub const pulsar_partitions_routing_mode_pulsar_RoundRobinDistribution:
    pulsar_partitions_routing_mode = 1;
pub const pulsar_partitions_routing_mode_pulsar_CustomPartition: pulsar_partitions_routing_mode = 2;
pub type pulsar_partitions_routing_mode = u32;
pub const pulsar_hashing_scheme_pulsar_Murmur3_32Hash: pulsar_hashing_scheme = 0;
pub const pulsar_hashing_scheme_pulsar_BoostHash: pulsar_hashing_scheme = 1;
pub const pulsar_hashing_scheme_pulsar_JavaStringHash: pulsar_hashing_scheme = 2;
pub type pulsar_hashing_scheme = u32;
pub const pulsar_compression_type_pulsar_CompressionNone: pulsar_compression_type = 0;
pub const pulsar_compression_type_pulsar_CompressionLZ4: pulsar_compression_type = 1;
pub const pulsar_compression_type_pulsar_CompressionZLib: pulsar_compression_type = 2;
pub type pulsar_compression_type = u32;
pub const pulsar_schema_type_pulsar_None: pulsar_schema_type = 0;
pub const pulsar_schema_type_pulsar_String: pulsar_schema_type = 1;
pub const pulsar_schema_type_pulsar_Json: pulsar_schema_type = 2;
pub const pulsar_schema_type_pulsar_Protobuf: pulsar_schema_type = 3;
pub const pulsar_schema_type_pulsar_Avro: pulsar_schema_type = 4;
pub const pulsar_schema_type_pulsar_Boolean: pulsar_schema_type = 5;
pub const pulsar_schema_type_pulsar_Int8: pulsar_schema_type = 6;
pub const pulsar_schema_type_pulsar_Int16: pulsar_schema_type = 7;
pub const pulsar_schema_type_pulsar_Int32: pulsar_schema_type = 8;
pub const pulsar_schema_type_pulsar_Int64: pulsar_schema_type = 9;
pub const pulsar_schema_type_pulsar_Float32: pulsar_schema_type = 10;
pub const pulsar_schema_type_pulsar_Float64: pulsar_schema_type = 11;
pub const pulsar_schema_type_pulsar_KeyValue: pulsar_schema_type = 15;
pub const pulsar_schema_type_pulsar_Bytes: pulsar_schema_type = -1;
pub const pulsar_schema_type_pulsar_AutoConsume: pulsar_schema_type = -3;
pub const pulsar_schema_type_pulsar_AutoPublish: pulsar_schema_type = -4;
pub type pulsar_schema_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_producer_configuration {
    _unused: [u8; 0],
}
pub type pulsar_producer_configuration_t = _pulsar_producer_configuration;
extern "C" {
    pub fn pulsar_producer_configuration_create() -> *mut pulsar_producer_configuration_t;
}
extern "C" {
    pub fn pulsar_producer_configuration_free(conf: *mut pulsar_producer_configuration_t);
}
extern "C" {
    pub fn pulsar_producer_configuration_set_producer_name(
        conf: *mut pulsar_producer_configuration_t,
        producerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_producer_name(
        conf: *mut pulsar_producer_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_send_timeout(
        conf: *mut pulsar_producer_configuration_t,
        sendTimeoutMs: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_send_timeout(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_initial_sequence_id(
        conf: *mut pulsar_producer_configuration_t,
        initialSequenceId: i64,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_initial_sequence_id(
        conf: *mut pulsar_producer_configuration_t,
    ) -> i64;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_compression_type(
        conf: *mut pulsar_producer_configuration_t,
        compressionType: pulsar_compression_type,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_compression_type(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_compression_type;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_schema_info(
        conf: *mut pulsar_producer_configuration_t,
        schemaType: pulsar_schema_type,
        name: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        properties: *mut pulsar_string_map_t,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_set_max_pending_messages(
        conf: *mut pulsar_producer_configuration_t,
        maxPendingMessages: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_max_pending_messages(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_max_pending_messages_across_partitions(
        conf: *mut pulsar_producer_configuration_t,
        maxPendingMessagesAcrossPartitions: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_max_pending_messages_across_partitions(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_partitions_routing_mode(
        conf: *mut pulsar_producer_configuration_t,
        mode: pulsar_partitions_routing_mode,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_partitions_routing_mode(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_partitions_routing_mode;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_message_router(
        conf: *mut pulsar_producer_configuration_t,
        router: pulsar_message_router,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_set_hashing_scheme(
        conf: *mut pulsar_producer_configuration_t,
        scheme: pulsar_hashing_scheme,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_hashing_scheme(
        conf: *mut pulsar_producer_configuration_t,
    ) -> pulsar_hashing_scheme;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_block_if_queue_full(
        conf: *mut pulsar_producer_configuration_t,
        blockIfQueueFull: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_block_if_queue_full(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_enabled(
        conf: *mut pulsar_producer_configuration_t,
        batchingEnabled: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_enabled(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_messages(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxMessages: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_messages(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_allowed_size_in_bytes(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxAllowedSizeInBytes: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_allowed_size_in_bytes(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_batching_max_publish_delay_ms(
        conf: *mut pulsar_producer_configuration_t,
        batchingMaxPublishDelayMs: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn pulsar_producer_configuration_get_batching_max_publish_delay_ms(
        conf: *mut pulsar_producer_configuration_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pulsar_producer_configuration_set_property(
        conf: *mut pulsar_producer_configuration_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_consumer_configuration {
    _unused: [u8; 0],
}
pub type pulsar_consumer_configuration_t = _pulsar_consumer_configuration;
pub const pulsar_consumer_type_pulsar_ConsumerExclusive: pulsar_consumer_type = 0;
pub const pulsar_consumer_type_pulsar_ConsumerShared: pulsar_consumer_type = 1;
pub const pulsar_consumer_type_pulsar_ConsumerFailover: pulsar_consumer_type = 2;
pub const pulsar_consumer_type_pulsar_ConsumerKeyShared: pulsar_consumer_type = 3;
pub type pulsar_consumer_type = u32;
pub const initial_position_initial_position_latest: initial_position = 0;
pub const initial_position_initial_position_earliest: initial_position = 1;
pub type initial_position = u32;
pub type pulsar_message_listener = ::std::option::Option<
    unsafe extern "C" fn(
        consumer: *mut pulsar_consumer_t,
        msg: *mut pulsar_message_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn pulsar_consumer_configuration_create() -> *mut pulsar_consumer_configuration_t;
}
extern "C" {
    pub fn pulsar_consumer_configuration_free(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_consumer_type(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        consumerType: pulsar_consumer_type,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_get_consumer_type(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> pulsar_consumer_type;
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_schema_info(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        schemaType: pulsar_schema_type,
        name: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        properties: *mut pulsar_string_map_t,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_message_listener(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        messageListener: pulsar_message_listener,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_has_message_listener(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_receiver_queue_size(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_get_receiver_queue_size(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_max_total_receiver_queue_size_across_partitions(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        maxTotalReceiverQueueSizeAcrossPartitions: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_max_total_receiver_queue_size_across_partitions(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_consumer_name(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        consumerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_consumer_name(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_consumer_set_unacked_messages_timeout_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        milliSeconds: u64,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_unacked_messages_timeout_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pulsar_configure_set_negative_ack_redelivery_delay_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        redeliveryDelayMillis: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn pulsar_configure_get_negative_ack_redelivery_delay_ms(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pulsar_consumer_is_encryption_enabled(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_is_read_compacted(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_read_compacted(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        compacted: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_consumer_get_subscription_initial_position(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_consumer_set_subscription_initial_position(
        consumer_configuration: *mut pulsar_consumer_configuration_t,
        subscriptionInitialPosition: initial_position,
    );
}
extern "C" {
    pub fn pulsar_consumer_configuration_set_property(
        conf: *mut pulsar_consumer_configuration_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_reader_configuration {
    _unused: [u8; 0],
}
pub type pulsar_reader_configuration_t = _pulsar_reader_configuration;
pub type pulsar_reader_listener = ::std::option::Option<
    unsafe extern "C" fn(
        reader: *mut pulsar_reader_t,
        msg: *mut pulsar_message_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn pulsar_reader_configuration_create() -> *mut pulsar_reader_configuration_t;
}
extern "C" {
    pub fn pulsar_reader_configuration_free(configuration: *mut pulsar_reader_configuration_t);
}
extern "C" {
    pub fn pulsar_reader_configuration_set_reader_listener(
        configuration: *mut pulsar_reader_configuration_t,
        listener: pulsar_reader_listener,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_has_reader_listener(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_receiver_queue_size(
        configuration: *mut pulsar_reader_configuration_t,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_receiver_queue_size(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_reader_name(
        configuration: *mut pulsar_reader_configuration_t,
        readerName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_reader_name(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_subscription_role_prefix(
        configuration: *mut pulsar_reader_configuration_t,
        subscriptionRolePrefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_get_subscription_role_prefix(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pulsar_reader_configuration_set_read_compacted(
        configuration: *mut pulsar_reader_configuration_t,
        readCompacted: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn pulsar_reader_configuration_is_read_compacted(
        configuration: *mut pulsar_reader_configuration_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_string_list {
    _unused: [u8; 0],
}
pub type pulsar_string_list_t = _pulsar_string_list;
extern "C" {
    pub fn pulsar_string_list_create() -> *mut pulsar_string_list_t;
}
extern "C" {
    pub fn pulsar_string_list_free(list: *mut pulsar_string_list_t);
}
extern "C" {
    pub fn pulsar_string_list_size(list: *mut pulsar_string_list_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pulsar_string_list_append(
        list: *mut pulsar_string_list_t,
        item: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn pulsar_string_list_get(
        map: *mut pulsar_string_list_t,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pulsar_client {
    _unused: [u8; 0],
}
pub type pulsar_client_t = _pulsar_client;
pub type pulsar_create_producer_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        producer: *mut pulsar_producer_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_subscribe_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        consumer: *mut pulsar_consumer_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_reader_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        reader: *mut pulsar_reader_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
pub type pulsar_get_partitions_callback = ::std::option::Option<
    unsafe extern "C" fn(
        result: pulsar_result,
        partitions: *mut pulsar_string_list_t,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn pulsar_client_create(
        serviceUrl: *const ::std::os::raw::c_char,
        clientConfiguration: *const pulsar_client_configuration_t,
    ) -> *mut pulsar_client_t;
}
extern "C" {
    pub fn pulsar_client_create_producer(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        conf: *const pulsar_producer_configuration_t,
        producer: *mut *mut pulsar_producer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_create_producer_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        conf: *const pulsar_producer_configuration_t,
        callback: pulsar_create_producer_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        consumer: *mut *mut pulsar_consumer_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_subscribe_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe_multi_topics_async(
        client: *mut pulsar_client_t,
        topics: *mut *const ::std::os::raw::c_char,
        topicsCount: ::std::os::raw::c_int,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_subscribe_pattern_async(
        client: *mut pulsar_client_t,
        topicPattern: *const ::std::os::raw::c_char,
        subscriptionName: *const ::std::os::raw::c_char,
        conf: *const pulsar_consumer_configuration_t,
        callback: pulsar_subscribe_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_create_reader(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        startMessageId: *const pulsar_message_id_t,
        conf: *mut pulsar_reader_configuration_t,
        reader: *mut *mut pulsar_reader_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_create_reader_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        startMessageId: *const pulsar_message_id_t,
        conf: *mut pulsar_reader_configuration_t,
        callback: pulsar_reader_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_get_topic_partitions(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        partitions: *mut *mut pulsar_string_list_t,
    ) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_get_topic_partitions_async(
        client: *mut pulsar_client_t,
        topic: *const ::std::os::raw::c_char,
        callback: pulsar_get_partitions_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_close(client: *mut pulsar_client_t) -> pulsar_result;
}
extern "C" {
    pub fn pulsar_client_close_async(
        client: *mut pulsar_client_t,
        callback: pulsar_close_callback,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pulsar_client_free(client: *mut pulsar_client_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
